library(AppliedPredictiveModeling)
library(AppliedPredictiveModeling)
library(caret)
data("segmentationOriginal")
segData <- subset(segmentationOriginal, Case == "Train")
cellID <- segData$Cell
calss <- segData$Class
case <- segData$Case
segData <- segData[ ,  -(1:3)]
statusColNum <- grep("Status", names(segData))
statusColNum
segData <- segData[ , -statusColNum]
# 同时进行中心化和标准化
scaled <- scale(segData[,c(1,4)], center = T, scale = T)
View(scaled)
e1071::skewness(segData$AngleCh1)
psych::skew(segData$AngleCh1)
e1071::skewness(segData$AngleCh1)
psych::skew(segData$AngleCh1)
psych::kurtosi(segData$AngleCh1) # 峰度
Ch1AreaTrans <- BoxCoxTrans(segData$AreaCh1)
Ch1AreaTrans
AreaCh1_transed <- predict(Ch1AreaTrans, segData$AreaCh1)
head(segData$AreaCh1)
head(AreaCh1_transed)
opar <- par(mfrow=c(1,2))
hist(segData$AreaCh1)
hist(AreaCh1_transed)
par(opar)
library(forecast)
best.lambda <- BoxCox.lambda(segData$AreaCh1)
best.lambda
AreaCh1.transformed <- BoxCox(segData$AreaCh1, lambda = best.lambda) # 变换
head(AreaCh1.transformed)
data(mdrr)
View(mdrrDescr)
plotSubset <- data.frame(scale(mdrrDescr[, c("nC", "X4v")]))
View(mdrrDescr)
data(mdrr)
transparentTheme(trans = .4) # 设置透明主题
plotSubset <- data.frame(scale(mdrrDescr[, c("nC", "X4v")]))
xyplot(nC ~ X4v,
data = plotSubset,
groups = mdrrClass,
auto.key = list(columns = 2)) # 自动生成图例，表示图例分两列显示
View(mdrrDescr)
mdrr$mdrrclass
mdrrDescr$mdrrClass
mdrrClass
# spatialSign变换
# 将每个数据点投影到单位圆（2D）或单位球面（高维）上
transformed <- spatialSign(plotSubset)
transformed <- as.data.frame(transformed)
xyplot(nC ~ X4v,
data = transformed,
groups = mdrrClass,
auto.key = list(columns = 2))
data(mdrr)
transparentTheme(trans = .4) # 设置透明主题
plotSubset <- data.frame(scale(mdrrDescr[, c("nC", "X4v")]))
xyplot(nC ~ X4v,
data = plotSubset,
groups = mdrrClass,
auto.key = list(columns = 2)) # 自动生成图例，表示图例分两列显示
# spatialSign变换
# 将每个数据点投影到单位圆（2D）或单位球面（高维）上
transformed <- spatialSign(plotSubset)
transformed <- as.data.frame(transformed)
xyplot(nC ~ X4v,
data = transformed,
groups = mdrrClass,
auto.key = list(columns = 2))
library(ggplot2)
View(segData)
pr <- prcomp(~ AvgIntenCh1 + EntropyIntenCh1,
data = segData,
scale. = TRUE)
View(pr)
pr[["x"]]
summary(pr)
pr$x
library(ggplot2)
p1 <- ggplot(segData, aes(AvgIntenCh1,EntropyIntenCh1))+
geom_point()+
labs(x="Channel 1 Fiber Width",y="Intensity Entropy Channel 1")+
theme_bw()
p2 <- ggplot(as.data.frame(pr$x), aes(PC1,PC2))+
geom_point()+
theme_bw()
cowplot::plot_grid(p1,p2)
data(mdrr)
table(mdrrDescr$nR11)
sd(mdrrDescr$nR11)^2
data(mdrr)
table(mdrrDescr$nR11)
sd(mdrrDescr$nR11)^2
# 检测并删除对建模无用的低方差变量
nzv <- nearZeroVar(mdrrDescr, saveMetrics= TRUE) # 返回详细统计指标
nzv[nzv$nzv,][1:10,] # 筛选并显示前10个近零方差变量
View(mdrrDescr)
dim(mdrrDescr)
nzv <- nearZeroVar(mdrrDescr)
filteredDescr <- mdrrDescr[, -nzv]
dim(filteredDescr)
View(segData)
correlations <- cor(segData)
View(correlations)
segData
dim(correlations)
library(corrplot)
corrplot(correlations,
order = "hclust", # 按层次聚类结果重新排列变量，使相关性高的变量在图中相邻
tl.col = "black") # 设置变量标签（text label）的颜色为黑色
corrplot(filteredSegData, order = 'hclust', tl.col = 'black')
highCorr <- findCorrelation(correlations, cutoff = 0.75)
length(highCorr)
filteredSegData <- segData[, -highCorr]
corrplot(filteredSegData, order = 'hclust', tl.col = 'black')
filtercorrelations <- cor(filteredSegData)
View(filtercorrelations)
corrplot(filtercorrelations, order = 'hclust', tl.col = 'black')
comboInfo <- findLinearCombos(correlations)
comboInfo
correlations[,-comboInfo$remove]
corrplot(correlations, order = 'hclust', tl.col = 'black')
?findLinearCombos
comboInfo <- findLinearCombos(filtercorrelations)
comboInfo
# Var40 = c1*Var23 + c2*Var24
filtercorrelations[,-comboInfo$remove]
comboInfo <- findLinearCombos(correlations)
comboInfo
# Var40 = c1*Var23 + c2*Var24
correlations[,-comboInfo$remove]
corrplot(correlations, order = 'hclust', tl.col = 'black')
comboInfo <- findLinearCombos(correlations)
comboInfo
# Var40 = c1*Var23 + c2*Var24
filtercorrelations <- correlations[,-comboInfo$remove]
corrplot(filtercorrelations, order = 'hclust', tl.col = 'black')
comboInfo <- findLinearCombos(correlations)
comboInfo
# Var40 = c1*Var23 + c2*Var24
filtercorrelations <- correlations[-comboInfo$remove, -comboInfo$remove]
corrplot(filtercorrelations, order = 'hclust', tl.col = 'black')
comboInfo <- findLinearCombos(correlations)
comboInfo
# Var40 = c1*Var23 + c2*Var24
correlations[, -comboInfo$remove]
corrplot(correlations, order = 'hclust', tl.col = 'black')
View(correlations)
correlations[, -comboInfo$remove]
data("cars", package = "caret")
head(cars)
View(cars)
type <- c("convertible", "coupe", "hatchback", "sedan", "wagon")
cars$Type <- factor(apply(cars[, 14:18], 1, function(x) type[which(x == 1)])) # 找到值为1的列索引
carSubset <- cars[sample(1:nrow(cars), 20), c(1, 2, 19)] # 保留第1、2和19列
carSubset
simpleMod <- dummyVars(~Mileage + Type,
data = carSubset,
levelsOnly = TRUE) # 简化列名：生成的哑变量列名仅保留因子水平
simpleMod
predict(simpleMod, head(carSubset))
View(simpleMod)
summary(simpleMod)
View(simpleMod)
simpleMod
predict(simpleMod, head(carSubset))
# 交互影响
withInteraction <- dummyVars(~Mileage + Type + Mileage:Type,
data = carSubset,
levelsOnly = TRUE)
withInteraction
predict(withInteraction, head(carSubset))
data("iris")
# 加载必要的库
library(ggplot2)
force(iris)
# 使用iris数据集和自定义主题创建箱线图
ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species)) +
geom_boxplot() +
labs(title = "花萼长度在不同鸢尾花物种中的分布",
x = "物种",
y = "花萼长度 (cm)") +
# 应用您提供的主题
theme_bw() +
theme(axis.text.x = element_text(size = 10,  color = "black"),
axis.text.y = element_text(size = 10, color = "black"),
axis.title.x = element_text(size = 12, face = "bold", color = "black"),
axis.title.y = element_text(size = 12, face = "bold", color = "black"),
panel.border = element_rect(color = "black", linewidth = 1),
plot.title = element_text(hjust = 0.5, size = 12),
strip.text = element_text(size = 12, face = "bold"),
legend.title = element_text(size = 10),
legend.text = element_text(size = 10))
library(GEOquery)
get <- getGEO(GEO = 'GSE265851', GPL=F)
get <- getGEO(GEO = 'GSE265851')
View(get)
get1 <- get$GSE265851_series_matrix.txt.gz@experimentData
get2 <- pData(get1)
View(get1)
get2 <- get1[[1]]
get2 <- get1[1]
get1 <- get[[1]]
get2 <- pData(get1)
View(get2)
get <- getGEO(GEO = 'GSE12027')
get1 <- get[[1]]
get2 <- pData(get1)
View(get2)
data <- rnorm(100,86,5)
hist(data)
hist(data, breaks = 10)
data > 81 & data < 91
data <- data.frame(n=data)
View(data)
data[which(data$n > 81 & data$n < 91),]
length(data[which(data$n > 81 & data$n < 91),])
data[which(data$n > 76 & data$n < 96),]
length(data[which(data$n > 76 & data$n < 96),])
data <- sample(c('A','B','C','D'),size = 20, replace = T)
data <- data.frame(n=data)
Length(data[which(data$n == 'A'),])
length(data[which(data$n == 'A'),])
setwd("D:/Github/ElectrophoresisZ.github.io/Wuthering_wave")
